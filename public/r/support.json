{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "support",
  "title": "Helper functions for TypeScript applications",
  "files": [
    {
      "path": "./src/support/array/index.ts",
      "content": "import { random } from \"../number/\";\r\n\r\nfunction range(start: number = 0, end?: number, step: number = 1) {\r\n  if (end === undefined) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n\r\n  if (step === 0)\r\n    step = 1;\r\n\r\n  step = start > end && step > 0 ? (step * -1) : step;\r\n\r\n  const length = Math.floor((end - start) / step) + 1;\r\n\r\n  return Array.from({ length }, (_, i) => start + (i * step));\r\n}\r\n\r\nfunction unique<TArray>(array: TArray[]) {\r\n  return [...new Set(array)];\r\n};\r\n\r\nfunction replace<TArray>(array: TArray[], index: number, value: TArray) {\r\n  array[index] = value;\r\n  return array;\r\n}\r\n\r\nfunction sample<TArray>(array: TArray[]) {\r\n  return array[random(array.length)];\r\n}\r\n\r\nfunction sum(array: number[]) {\r\n  let total = 0;\r\n  array.forEach(e => total += e);\r\n  return total;\r\n}\r\n\r\nfunction chunk<TArray>(array: TArray[], size: number) {\r\n  let chunkedNumber = 0;\r\n  const chunkedArray: unknown[] = [];\r\n  array.forEach(() => {\r\n    if (chunkedNumber === array.length)\r\n      return;\r\n\r\n    const slicedArray = array.slice(chunkedNumber, chunkedNumber + size);\r\n    if (slicedArray.length === 0)\r\n      return;\r\n    chunkedArray.push(slicedArray);\r\n    chunkedNumber += size;\r\n  });\r\n\r\n  return chunkedArray;\r\n}\r\n\r\nfunction compact<TArray>(array: TArray[]) {\r\n  return array.filter(e => e);\r\n}\r\n\r\nfunction difference<TFirstArray, TSecondArray>(firstArray: TFirstArray[], secondArray: TSecondArray[]) {\r\n  return firstArray.filter(f => !secondArray.includes(f));\r\n}\r\n\r\nfunction remove<TArray>(array: TArray[], value: TArray) {\r\n  const index = array.indexOf(value);\r\n  if (index === -1)\r\n    return array;\r\n  array.splice(index, 1);\r\n  return array;\r\n}\r\n\r\nfunction shuffle<TArray>(array: TArray[]) {\r\n  let currentIndex = array.length;\r\n  while (currentIndex !== 0) {\r\n    const randomIndex = random(0, currentIndex);\r\n    currentIndex--;\r\n\r\n    const temp = array[currentIndex];\r\n    array[currentIndex] = array[randomIndex]!;\r\n    array[randomIndex] = temp!;\r\n  }\r\n  return array;\r\n}\r\n\r\nfunction head<TArray>(array: TArray[]) {\r\n  return array[0];\r\n}\r\n\r\nfunction last<TArray>(array: TArray[]) {\r\n  return array[array.length - 1];\r\n}\r\n\r\nfunction nth<TArray>(array: TArray[], n: number) {\r\n  return array[n];\r\n}\r\n\r\nfunction intersection<TFirstArray, TSecondArray>(firstArray: TFirstArray[], secondArray: TSecondArray[]) {\r\n  return firstArray.filter(e => secondArray.includes(e));\r\n}\r\n\r\nfunction tail<TArray>(array: TArray[]) {\r\n  array.shift();\r\n  return array;\r\n}\r\n\r\nfunction take<TArray>(array: TArray[], n: number = 0) {\r\n  return array.slice(0, n);\r\n}\r\n\r\nfunction union<TFirstArray, TSecondArray>(firstArray: TFirstArray[], secondArray: TSecondArray[]) {\r\n  return [...new Set([...firstArray, ...secondArray])]; ;\r\n}\r\n\r\nexport { chunk, compact, difference, head, intersection, last, nth, range, remove, replace, sample, shuffle, sum, tail, take, union, unique };\r\n",
      "type": "registry:lib",
      "target": "lib/support/array.ts"
    },
    {
      "path": "./src/support/string/index.ts",
      "content": "const SPECIAL_CHARTERS = `!\"#$%&'()*+,-./:;<=>?@[\\\\]^_\\`{|}~`;\r\nconst SPECIAL_CHARTERS_REGEX = /[!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~\\s]+/g;\r\n\r\nfunction after(text: string, value: string): string {\r\n  const index = text.indexOf(value);\r\n\r\n  if (index === -1)\r\n    return \"\";\r\n  return text.slice(index + value.length);\r\n}\r\n\r\nfunction append(text: string, appendedString: string) {\r\n  if (appendedString.length === 0)\r\n    return text;\r\n\r\n  return text + appendedString;\r\n}\r\n\r\nfunction before(text: string, value: string): string {\r\n  const index = text.indexOf(value);\r\n\r\n  if (index === -1)\r\n    return \"\";\r\n  return text.slice(0, index);\r\n}\r\n\r\nfunction between(text: string, firstValue: string, secondValue: string): string {\r\n  return text.slice(text.indexOf(firstValue) + firstValue.length, text.indexOf(secondValue));\r\n}\r\n\r\nfunction trim(text: string, characters: string): string {\r\n  if (!text || !characters)\r\n    return text;\r\n  const escaped = characters.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n  const regex = new RegExp(`^[${escaped}]+|[${escaped}]+$`, \"g\");\r\n\r\n  return text.replace(regex, \"\");\r\n}\r\n\r\nfunction camel(text: string): string {\r\n  return text.split(SPECIAL_CHARTERS_REGEX).map((str, index) => index === 0 ? str.toLowerCase() : capitalize(str)).join(\"\");\r\n}\r\n\r\nfunction capitalize(text: string): string {\r\n  return text.charAt(0).toUpperCase() + text.slice(1);\r\n}\r\n\r\nfunction headline(text: string): string {\r\n  return text.split(/(?<!^)(?=[A-Z])|[_\\-\\s]+/g).map(str => capitalize(str)).join(\" \");\r\n}\r\n\r\nfunction kebab(text: string): string {\r\n  return text\r\n    .replace(/([a-z0-9])([A-Z])|[_\\s]+/g, (_, a, b) => a && b ? `${a}-${b}` : \"-\")\r\n    .toLowerCase();\r\n}\r\n\r\nfunction lowerCaseFirst(text: string): string {\r\n  return text.charAt(0).toLowerCase() + text.slice(1);\r\n}\r\n\r\nfunction limit(text: string, length: number, appendedString: string = \"...\"): string {\r\n  return text.length > length ? text.slice(0, length).concat(appendedString) : text;\r\n}\r\n\r\nfunction mask(text: string, paddingCharacter: string = \"*\", length: number) {\r\n  return text.slice(0, length) + paddingCharacter.repeat(text.length - length);\r\n}\r\n\r\nfunction pad(text: string, length: number, paddingCharacter: string = \" \", direction: \"pad-center\" | \"pad-left\" | \"pad-right\" = \"pad-center\") {\r\n  const textLength = text.length;\r\n\r\n  if (text.length >= length)\r\n    return text;\r\n\r\n  const totalPadding = length - textLength;\r\n  const leftPadding = Math.floor(totalPadding / 2);\r\n  const rightPadding = totalPadding - leftPadding;\r\n\r\n  switch (direction) {\r\n    case \"pad-center\" :\r\n      return paddingCharacter.repeat(leftPadding) + text + paddingCharacter.repeat(rightPadding);\r\n    case \"pad-left\" :\r\n      return paddingCharacter.repeat(totalPadding) + text;\r\n    case \"pad-right\" :\r\n      return text + paddingCharacter.repeat(totalPadding);\r\n  }\r\n}\r\n\r\nfunction random(length: number, characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"): string {\r\n  let result = \"\";\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    result += characters.charAt(Math.floor(Math.random() * characters.length));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction slug(text: string, character: string = \"-\") {\r\n  return text\r\n    .toLowerCase()\r\n    .normalize(\"NFD\")\r\n    .replace(/[\\u0300-\\u036F]/g, \"\")\r\n    .trim()\r\n    .replace(/[^a-z0-9 -]/g, \"\")\r\n    .replace(/\\s+/g, character)\r\n    .replace(/-+/g, \"-\");\r\n}\r\n\r\nfunction squish(text: string) {\r\n  return text.replace(/\\s+/g, \" \").trim();\r\n}\r\n\r\nfunction snake(text: string): string {\r\n  return text\r\n    .replace(/([a-z0-9])([A-Z])/g, \"$1_$2\")\r\n    .replace(/[\\s-]+/g, \"_\")\r\n    .toLowerCase();\r\n}\r\n\r\nfunction studly(text: string): string {\r\n  return text\r\n    .replace(/[_\\-\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\r\n    .replace(/^(.)/, c => c.toUpperCase());\r\n}\r\n\r\nfunction swap(object: Record<string, string>, text: string): string {\r\n  let result = text;\r\n\r\n  for (const [key, value] of Object.entries(object)) {\r\n    result = result.replaceAll(key, value);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction uuid(): string {\r\n  const now = Date.now();\r\n  const timeHex = now.toString(16).padStart(12, \"0\");\r\n\r\n  const random = crypto.getRandomValues(new Uint8Array(10));\r\n  const randomHex = [...random].map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\r\n\r\n  return (\r\n    `${timeHex.slice(0, 8)}-${\r\n      timeHex.slice(8, 12)}-7${\r\n      randomHex.slice(0, 3)}-${\r\n      ((Number.parseInt(randomHex.charAt(3), 16) & 0x3) | 0x8).toString(16)\r\n    }${randomHex.slice(4, 7)}-${\r\n      randomHex.slice(7)}`\r\n  );\r\n}\r\n\r\nfunction title(text: string): string {\r\n  return text\r\n    .toLowerCase()\r\n    .replace(/\\b\\p{L}/gu, char => char.toUpperCase());\r\n}\r\n\r\nfunction upperCaseFirst(text: string): string {\r\n  return text.charAt(0).toUpperCase() + text.slice(1);\r\n}\r\n\r\nfunction wordCount(text: string): number {\r\n  return text.trim().split(/\\s+/).length;\r\n}\r\n\r\nfunction truncate(text: string, length: number = 20, omission: string = \"...\") {\r\n  return text.length > length ? `${text.slice(0, length)}${omission}` : text;\r\n}\r\n\r\nconst str = {\r\n  after,\r\n  append,\r\n  before,\r\n  between,\r\n  trim,\r\n  camel,\r\n  capitalize,\r\n  headline,\r\n  kebab,\r\n  lowerCaseFirst,\r\n  limit,\r\n  pad,\r\n  mask,\r\n  random,\r\n  slug,\r\n  snake,\r\n  squish,\r\n  studly,\r\n  swap,\r\n  title,\r\n  upperCaseFirst,\r\n  uuid,\r\n  wordCount,\r\n  truncate,\r\n};\r\n\r\nexport default str;\r\nexport { after, append, before, between, camel, capitalize, headline, kebab, limit, lowerCaseFirst, mask, pad, random, slug, snake, SPECIAL_CHARTERS, SPECIAL_CHARTERS_REGEX, squish, studly, swap, title, trim, truncate, upperCaseFirst, uuid, wordCount };\r\n",
      "type": "registry:lib",
      "target": "lib/support/string.ts"
    },
    {
      "path": "./src/support/number/index.ts",
      "content": "function between(number: number, start: number, end: number) {\r\n  return number <= end && number >= start;\r\n}\r\n\r\nfunction random(start: number, end?: number): number {\r\n  if (!end) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n\r\n  return Math.floor(Math.random() * (end - start));\r\n}\r\n\r\nfunction abbreviate(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    compactDisplay: \"short\",\r\n    maximumFractionDigits: 1,\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number) {\r\n  if (value <= min)\r\n    return min;\r\n\r\n  if (value >= max)\r\n    return max;\r\n\r\n  return value;\r\n}\r\n\r\nfunction currency(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    style: \"currency\",\r\n    currency: \"USD\",\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction fileSize(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    style: \"unit\",\r\n    unit: \"byte\",\r\n    unitDisplay: \"narrow\",\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction forHumans(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    compactDisplay: \"long\",\r\n    ...options,\r\n  }).format(value);\r\n};\r\n\r\nfunction ordinal(value: number) {\r\n  const englishOrdinalRules = new Intl.PluralRules(\"en-US\", { type: \"ordinal\" }).select(value) as \"one\" | \"two\" | \"few\" | \"other\";\r\n\r\n  const suffix = {\r\n    one: \"st\",\r\n    two: \"nd\",\r\n    few: \"rd\",\r\n    other: \"th\",\r\n  };\r\n\r\n  return value + suffix[englishOrdinalRules];\r\n}\r\n\r\nfunction percentage(value: number, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    style: \"percent\",\r\n    ...options,\r\n  }).format(value / 100);\r\n}\r\n\r\nexport { abbreviate, between, clamp, currency, fileSize, forHumans, ordinal, percentage, random };\r\n",
      "type": "registry:lib",
      "target": "lib/support/number.ts"
    },
    {
      "path": "./src/support/benchmark/index.ts",
      "content": "function benchmark(callback: CallableFunction) {\r\n  const start = performance.now();\r\n  callback();\r\n  const end = performance.now();\r\n  const elapsedTime = end - start;\r\n\r\n  console.info(`Execution time: ${(elapsedTime).toFixed(2)} ms`);\r\n}\r\n\r\nexport { benchmark };\r\n",
      "type": "registry:lib",
      "target": "lib/support/benchmark.ts"
    },
    {
      "path": "./src/support/cookies/index.ts",
      "content": "type CookieValue = string | number | boolean | object | null | undefined;\r\n\r\ntype CookieOptions = {\r\n  expires?: number | Date;\r\n  path?: string;\r\n  domain?: string;\r\n  secure?: boolean;\r\n  sameSite?: \"Strict\" | \"Lax\" | \"None\";\r\n};\r\n\r\nclass CookieManager {\r\n  set(name: string, value: CookieValue, options: CookieOptions = {}): void {\r\n    const stringValue = typeof value === \"object\"\r\n      ? JSON.stringify(value)\r\n      : String(value);\r\n\r\n    let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(stringValue)}`;\r\n\r\n    if (options.expires) {\r\n      const expires = options.expires instanceof Date\r\n        ? options.expires\r\n        : new Date(Date.now() + options.expires * 1000);\r\n      cookie += `; expires=${expires.toUTCString()}`;\r\n    }\r\n\r\n    if (options.path) {\r\n      cookie += `; path=${options.path}`;\r\n    }\r\n\r\n    if (options.domain) {\r\n      cookie += `; domain=${options.domain}`;\r\n    }\r\n\r\n    if (options.secure) {\r\n      cookie += \"; secure\";\r\n    }\r\n\r\n    if (options.sameSite) {\r\n      cookie += `; SameSite=${options.sameSite}`;\r\n    }\r\n\r\n    document.cookie = cookie;\r\n  }\r\n\r\n  get(name: string): string | null {\r\n    const nameEQ = `${encodeURIComponent(name)}=`;\r\n    const cookies = document.cookie.split(\";\");\r\n\r\n    for (let cookie of cookies) {\r\n      cookie = cookie.trim();\r\n      if (cookie.startsWith(nameEQ)) {\r\n        const value = cookie.substring(nameEQ.length);\r\n        return decodeURIComponent(value);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  has(name: string): boolean {\r\n    return this.get(name) !== null;\r\n  }\r\n\r\n  remove(name: string, options: Omit<CookieOptions, \"expires\"> = {}): void {\r\n    this.set(name, \"\", {\r\n      ...options,\r\n      expires: new Date(0),\r\n    });\r\n  }\r\n\r\n  clear(): void {\r\n    const cookies = document.cookie.split(\";\");\r\n\r\n    for (const cookie of cookies) {\r\n      const name = cookie.split(\"=\")?.[0]?.trim();\r\n      if (name) {\r\n        this.remove(name);\r\n      }\r\n    }\r\n  }\r\n\r\n  all(): Record<string, string> {\r\n    const result: Record<string, string> = {};\r\n    const cookies = document.cookie.split(\";\");\r\n\r\n    for (let cookie of cookies) {\r\n      cookie = cookie.trim();\r\n      if (cookie) {\r\n        const [name, ...valueParts] = cookie.split(\"=\");\r\n        const value = valueParts.join(\"=\");\r\n        if (name) {\r\n          result[decodeURIComponent(name)] = decodeURIComponent(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  mapped(): Map<string, string> {\r\n    const map = new Map<string, string>();\r\n    const all = this.all();\r\n\r\n    for (const [key, value] of Object.entries(all)) {\r\n      map.set(key, value);\r\n    }\r\n\r\n    return map;\r\n  }\r\n}\r\n\r\nconst cookies = new CookieManager();\r\n\r\nexport { CookieManager, cookies };\r\nexport type { CookieOptions, CookieValue };\r\n",
      "type": "registry:lib",
      "target": "lib/support/cookies.ts"
    },
    {
      "path": "./src/support/fetch/index.ts",
      "content": "import { trim } from \"../string\";\r\n\r\ntype QueryParams\r\n  = | string\r\n    | Record<string, string | number | boolean | null | undefined>\r\n    | string[][]\r\n    | URLSearchParams;\r\n\r\ntype FetchClientConfig = {\r\n  baseUrl: string;\r\n  headers?: HeadersInit;\r\n};\r\n\r\ntype ResponseType = \"json\" | \"text\" | \"blob\" | \"arrayBuffer\" | \"response\";\r\n\r\ntype RequestOptions = {\r\n  headers?: HeadersInit;\r\n  params?: QueryParams;\r\n  responseType?: ResponseType;\r\n} & Omit<RequestInit, \"method\" | \"headers\">;\r\n\r\nclass FetchError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public status: number,\r\n    public statusText: string,\r\n    public response: Response,\r\n  ) {\r\n    super(message);\r\n    this.name = \"FetchError\";\r\n  }\r\n}\r\n\r\nfunction createFetchClient({ baseUrl, headers: defaultHeaders = {} }: FetchClientConfig) {\r\n  const normalizeUrl = (path: string, params?: QueryParams): string => {\r\n    const cleanBase = trim(baseUrl, \"/\");\r\n    const cleanPath = trim(path, \"/\");\r\n    const url = new URL(`${cleanBase}/${cleanPath}`);\r\n\r\n    if (params) {\r\n      url.search\r\n        = params instanceof URLSearchParams\r\n          ? params.toString()\r\n          : new URLSearchParams(params as Record<string, string>).toString();\r\n    }\r\n\r\n    return url.toString();\r\n  };\r\n\r\n  const parseResponse = async <T>(\r\n    response: Response,\r\n    responseType: ResponseType = \"json\",\r\n  ): Promise<T> => {\r\n    switch (responseType) {\r\n      case \"json\":\r\n        return await response.json();\r\n      case \"text\":\r\n        return (await response.text()) as T;\r\n      case \"blob\":\r\n        return (await response.blob()) as T;\r\n      case \"arrayBuffer\":\r\n        return (await response.arrayBuffer()) as T;\r\n      case \"response\":\r\n        return response as T;\r\n      default:\r\n        return await response.json();\r\n    }\r\n  };\r\n\r\n  const request = async <T>(\r\n    method: string,\r\n    path: string,\r\n    options: RequestOptions = {},\r\n  ): Promise<T> => {\r\n    const { params, headers: customHeaders, responseType = \"json\", ...fetchOptions } = options;\r\n\r\n    const url = normalizeUrl(path, params);\r\n\r\n    const response = await fetch(url, {\r\n      method,\r\n      headers: {\r\n        ...defaultHeaders,\r\n        ...customHeaders,\r\n      },\r\n      ...fetchOptions,\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new FetchError(\r\n        `Request failed: ${response.status} ${response.statusText}`,\r\n        response.status,\r\n        response.statusText,\r\n        response,\r\n      );\r\n    }\r\n\r\n    return parseResponse<T>(response, responseType);\r\n  };\r\n\r\n  const requestWithBody = <T>(\r\n    method: string,\r\n    path: string,\r\n    body?: unknown,\r\n    options: RequestOptions = {},\r\n  ): Promise<T> => {\r\n    const isFormData = body instanceof FormData;\r\n    const headers: HeadersInit = {\r\n      ...(!isFormData && { \"Content-Type\": \"application/json\" }),\r\n      ...options.headers,\r\n    };\r\n\r\n    return request<T>(method, path, {\r\n      ...options,\r\n      body: isFormData ? body : body ? JSON.stringify(body) : undefined,\r\n      headers,\r\n    });\r\n  };\r\n\r\n  return {\r\n    get: <T>(path: string, options?: RequestOptions) =>\r\n      request<T>(\"GET\", path, options),\r\n\r\n    post: <T>(path: string, body?: unknown, options?: RequestOptions) =>\r\n      requestWithBody<T>(\"POST\", path, body, options),\r\n\r\n    put: <T>(path: string, body?: unknown, options?: RequestOptions) =>\r\n      requestWithBody<T>(\"PUT\", path, body, options),\r\n\r\n    patch: <T>(path: string, body?: unknown, options?: RequestOptions) =>\r\n      requestWithBody<T>(\"PATCH\", path, body, options),\r\n\r\n    delete: <T>(path: string, options?: RequestOptions) =>\r\n      request<T>(\"DELETE\", path, options),\r\n  };\r\n}\r\n\r\nexport { createFetchClient, FetchError };\r\nexport type { FetchClientConfig, QueryParams, RequestOptions, ResponseType };\r\n",
      "type": "registry:lib",
      "target": "lib/support/fetch.ts"
    },
    {
      "path": "./src/support/file-system/index.ts",
      "content": "import * as fs from \"node:fs/promises\";\r\n\r\nimport { basePath, folderName } from \"../path\";\r\nimport { after } from \"../string\";\r\n\r\nconst fileSystem = {\r\n  async get(path: string, options: Parameters<typeof fs.readFile>[1] = { encoding: \"utf-8\" }) {\r\n    return await fs.readFile(basePath(path), options);\r\n  },\r\n  async pathExists(path: string) {\r\n    try {\r\n      await fs.stat(basePath(path));\r\n      return true;\r\n    }\r\n    catch {\r\n      return false;\r\n    }\r\n  },\r\n  async fileExists(path: string) {\r\n    return (await fs.stat(basePath(path))).isFile();\r\n  },\r\n  async folderExists(path: string) {\r\n    return (await fs.stat(basePath(path))).isDirectory();\r\n  },\r\n  async createDirectory(path: string, options: Parameters<typeof fs.mkdir>[1] = { recursive: true }) {\r\n    await fs.mkdir(basePath(path), options);\r\n  },\r\n  async createDirectoryIfNotExists(path: string) {\r\n    const directory = after(folderName(path), basePath());\r\n    if (!await this.pathExists(directory)) {\r\n      await this.createDirectory(directory);\r\n    }\r\n  },\r\n  async createFile(path: string, options: Parameters<typeof fs.writeFile>[2] = \"utf-8\") {\r\n    await this.createDirectoryIfNotExists(path);\r\n\r\n    await fs.writeFile(basePath(path), \"\", options);\r\n  },\r\n  async write(pathToWrite: string, data: string | NodeJS.ArrayBufferView, options: Parameters<typeof fs.writeFile>[2] = \"utf-8\") {\r\n    await this.createDirectoryIfNotExists(pathToWrite);\r\n\r\n    await fs.writeFile(basePath(pathToWrite), data, options);\r\n  },\r\n  async append(path: string, data: string | Uint8Array, options?: Parameters<typeof fs.appendFile>[2]) {\r\n    await fs.appendFile(basePath(path), data, options);\r\n  },\r\n  async replaceContent(path: string, searchValue: string | RegExp, replaceValue: string) {\r\n    const file = (await this.get(path)).toString();\r\n\r\n    await this.write(path, file.replace(searchValue, replaceValue));\r\n  },\r\n  async symbolicLink(target: string, path: string) {\r\n    await fs.symlink(basePath(target), basePath(path));\r\n  },\r\n  async temporary(prefix: string, options?: Parameters<typeof fs.mkdtemp>[1]) {\r\n    await fs.mkdtemp(prefix, options);\r\n  },\r\n  async rename(pathFrom: string, newPath: string) {\r\n    await fs.rename(basePath(pathFrom), basePath(newPath));\r\n  },\r\n  async copy(copyFrom: string, copyTo: string, options: Parameters<typeof fs.cp>[2] = { recursive: true }) {\r\n    await fs.cp(basePath(copyFrom), basePath(copyTo), options);\r\n  },\r\n  async cut(cutFrom: string, cutTo: string) {\r\n    await this.copy(cutFrom, cutTo);\r\n\r\n    await this.remove(cutFrom, { recursive: true });\r\n  },\r\n  async remove(path: string, options?: Parameters<typeof fs.rm>[1]) {\r\n    await fs.rm(basePath(path), options);\r\n  },\r\n};\r\n\r\nexport { fileSystem };\r\n",
      "type": "registry:lib",
      "target": "lib/support/file-system.ts"
    },
    {
      "path": "./src/support/hash/index.ts",
      "content": "import { Buffer } from \"node:buffer\";\r\nimport { createCipheriv, createDecipheriv, createHash, createHmac, randomBytes, timingSafeEqual } from \"node:crypto\";\r\n\r\ntype HashedAlgorithm = \"sha256\" | \"sha384\" | \"sha512\";\r\nconst DEFAULT_HASHED_ALGORITHM = \"sha256\" satisfies HashedAlgorithm;\r\n\r\ntype EncryptionAlgorithmType = \"aes-256-cbc\";\r\nconst DEFAULT_ENCRYPTION_ALGORITHM = \"aes-256-cbc\" satisfies EncryptionAlgorithmType;\r\n\r\nfunction generateKey(size: number = 32) {\r\n  return randomBytes(size).toString(\"base64\");\r\n}\r\n\r\n// ============ HASHING (One-way, no secret) ============\r\nfunction hash(data: string, algorithm: HashedAlgorithm = DEFAULT_HASHED_ALGORITHM) {\r\n  return createHash(algorithm).update(data).digest(\"hex\");\r\n}\r\n\r\nfunction verifyHash(\r\n  plainText: string,\r\n  hashedValue: string,\r\n  algorithm: HashedAlgorithm = DEFAULT_HASHED_ALGORITHM,\r\n): boolean {\r\n  const newHash = hash(plainText, algorithm);\r\n  return newHash === hashedValue;\r\n}\r\n\r\n// ============ HMAC (One-way, with secret) ============\r\n\r\nfunction sign(data: string, secret: string, algorithm: HashedAlgorithm = DEFAULT_HASHED_ALGORITHM) {\r\n  return createHmac(algorithm, secret)\r\n    .update(data)\r\n    .digest(\"hex\");\r\n}\r\n\r\nfunction verifySign(data: string, signature: string, secret: string, algorithm: HashedAlgorithm = DEFAULT_HASHED_ALGORITHM,\r\n): boolean {\r\n  const expected = sign(data, secret, algorithm);\r\n\r\n  return timingSafeEqual(\r\n    Buffer.from(expected),\r\n    Buffer.from(signature),\r\n  );\r\n}\r\n\r\n// ============ ENCRYPTION (Two-way, reversible) ============\r\n\r\nfunction encrypt(data: string, key: string, algorithm: EncryptionAlgorithmType = DEFAULT_ENCRYPTION_ALGORITHM): string {\r\n  const iv = randomBytes(16);\r\n\r\n  const keyBuffer = Buffer.from(key, \"base64\");\r\n  const cipher = createCipheriv(algorithm, keyBuffer, iv);\r\n\r\n  let encrypted = cipher.update(data, \"utf8\", \"base64\");\r\n  encrypted += cipher.final(\"base64\");\r\n\r\n  // Create payload\r\n  const payload = {\r\n    iv: iv.toString(\"base64\"),\r\n    value: encrypted,\r\n    mac: \"\",\r\n  };\r\n\r\n  const payloadStr = Buffer.from(JSON.stringify(payload)).toString(\"base64\");\r\n  const mac = createHmac(\"sha256\", key)\r\n    .update(payloadStr)\r\n    .digest(\"hex\");\r\n\r\n  payload.mac = mac;\r\n\r\n  return Buffer.from(JSON.stringify(payload)).toString(\"base64\");\r\n}\r\n\r\nfunction decrypt(encrypted: string, key: string, algorithm: EncryptionAlgorithmType = DEFAULT_ENCRYPTION_ALGORITHM): string {\r\n  // Parse payload\r\n  const payloadStr = Buffer.from(encrypted, \"base64\").toString(\"utf8\");\r\n  const payload = JSON.parse(payloadStr);\r\n\r\n  // Verify MAC\r\n  const dataToVerify = Buffer.from(JSON.stringify({\r\n    iv: payload.iv,\r\n    value: payload.value,\r\n    mac: \"\",\r\n  })).toString(\"base64\");\r\n\r\n  const expectedMac = createHmac(\"sha256\", key)\r\n    .update(dataToVerify)\r\n    .digest(\"hex\");\r\n\r\n  if (payload.mac !== expectedMac) {\r\n    throw new Error(\"MAC verification failed\");\r\n  }\r\n\r\n  // Decrypt\r\n  const keyBuffer = Buffer.from(key, \"base64\");\r\n  const iv = Buffer.from(payload.iv, \"base64\");\r\n  const decipher = createDecipheriv(algorithm, keyBuffer, iv);\r\n\r\n  let decrypted = decipher.update(payload.value, \"base64\", \"utf8\");\r\n  decrypted += decipher.final(\"utf8\");\r\n\r\n  return decrypted;\r\n}\r\n\r\nexport { decrypt, encrypt, generateKey, hash, sign, verifyHash, verifySign };\r\n",
      "type": "registry:lib",
      "target": "lib/support/hash.ts"
    },
    {
      "path": "./src/support/number/index.ts",
      "content": "function between(number: number, start: number, end: number) {\r\n  return number <= end && number >= start;\r\n}\r\n\r\nfunction random(start: number, end?: number): number {\r\n  if (!end) {\r\n    end = start;\r\n    start = 0;\r\n  }\r\n\r\n  return Math.floor(Math.random() * (end - start));\r\n}\r\n\r\nfunction abbreviate(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    compactDisplay: \"short\",\r\n    maximumFractionDigits: 1,\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction clamp(value: number, min: number, max: number) {\r\n  if (value <= min)\r\n    return min;\r\n\r\n  if (value >= max)\r\n    return max;\r\n\r\n  return value;\r\n}\r\n\r\nfunction currency(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    style: \"currency\",\r\n    currency: \"USD\",\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction fileSize(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    style: \"unit\",\r\n    unit: \"byte\",\r\n    unitDisplay: \"narrow\",\r\n    ...options,\r\n  }).format(value);\r\n}\r\n\r\nfunction forHumans(value: number | bigint, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    notation: \"compact\",\r\n    compactDisplay: \"long\",\r\n    ...options,\r\n  }).format(value);\r\n};\r\n\r\nfunction ordinal(value: number) {\r\n  const englishOrdinalRules = new Intl.PluralRules(\"en-US\", { type: \"ordinal\" }).select(value) as \"one\" | \"two\" | \"few\" | \"other\";\r\n\r\n  const suffix = {\r\n    one: \"st\",\r\n    two: \"nd\",\r\n    few: \"rd\",\r\n    other: \"th\",\r\n  };\r\n\r\n  return value + suffix[englishOrdinalRules];\r\n}\r\n\r\nfunction percentage(value: number, options?: Intl.NumberFormatOptions, locale: Intl.LocalesArgument = \"en-US\") {\r\n  return new Intl.NumberFormat(locale, {\r\n    style: \"percent\",\r\n    ...options,\r\n  }).format(value / 100);\r\n}\r\n\r\nexport { abbreviate, between, clamp, currency, fileSize, forHumans, ordinal, percentage, random };\r\n",
      "type": "registry:lib",
      "target": "lib/support/number.ts"
    },
    {
      "path": "./src/support/object/index.ts",
      "content": "function isEqual(first: unknown, other: unknown): boolean {\r\n  if (first === other)\r\n    return true;\r\n\r\n  if (Number.isNaN(first) && Number.isNaN(other))\r\n    return true;\r\n\r\n  if (\r\n    typeof first !== \"object\" || first === null\r\n    || typeof other !== \"object\" || other === null\r\n  ) {\r\n    return false;\r\n  }\r\n\r\n  const objA = first as Record<PropertyKey, unknown>;\r\n  const objB = other as Record<PropertyKey, unknown>;\r\n\r\n  const keysA = Object.keys(objA);\r\n  const keysB = Object.keys(objB);\r\n\r\n  if (keysA.length !== keysB.length)\r\n    return false;\r\n\r\n  for (const key of keysA) {\r\n    if (!keysB.includes(key) || !isEqual(objA[key], objB[key]))\r\n      return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction add<TObj, TKey extends PropertyKey, TValue>(object: TObj, key: TKey, value: TValue) {\r\n  return { ...object, [key]: value };\r\n}\r\n\r\nfunction remove<TObj, TKey extends readonly (keyof TObj)[]>(object: TObj, ...keys: TKey) {\r\n  const newObject = { ...object };\r\n  keys.forEach(key => delete newObject[key]);\r\n  return newObject;\r\n}\r\n\r\nexport { add, isEqual, remove };\r\n",
      "type": "registry:lib",
      "target": "lib/support/object.ts"
    },
    {
      "path": "./src/support/path/index.ts",
      "content": "import path from \"node:path\";\r\n\nfunction basePath(pathTo: string = \"\") {\r\n  return path.join(process.cwd(), pathTo);\r\n}\r\n\r\nfunction appPath(pathTo: string = \"\") {\r\n  return path.join(process.cwd(), \"app\", pathTo);\r\n}\r\n\r\nfunction publicPath(pathTo: string = \"\") {\r\n  return path.join(process.cwd(), \"public\", pathTo);\r\n}\r\n\r\nfunction fileName(pathTo: string) {\r\n  return path.basename(pathTo);\r\n}\r\n\r\nfunction folderName(pathTo: string) {\r\n  const parsedObject = path.parse(basePath(pathTo));\r\n  return parsedObject.ext === \"\" ? path.join(parsedObject.dir, parsedObject.name) : parsedObject.dir;\r\n}\r\n\r\nfunction extension(pathTo: string) {\r\n  return path.extname(pathTo);\r\n}\r\n\r\nexport { appPath, basePath, extension, fileName, folderName, publicPath };\r\n",
      "type": "registry:lib",
      "target": "lib/support/path.ts"
    },
    {
      "path": "./src/support/utils/index.ts",
      "content": "function oldSchoolCopy(text: string): boolean {\r\n  const tempTextArea = document.createElement(\"textarea\");\r\n\r\n  tempTextArea.value = text;\r\n  tempTextArea.style.position = \"fixed\";\r\n  tempTextArea.style.left = \"-999999px\";\r\n  tempTextArea.style.top = \"-999999px\";\r\n  tempTextArea.setAttribute(\"readonly\", \"\");\r\n  tempTextArea.setAttribute(\"aria-hidden\", \"true\");\r\n\r\n  document.body.appendChild(tempTextArea);\r\n\r\n  tempTextArea.focus();\r\n  tempTextArea.select();\r\n\r\n  let success = false;\r\n  try {\r\n    success = document.execCommand(\"copy\");\r\n  }\r\n  catch (error) {\r\n    console.error(\"Failed to copy using execCommand:\", error);\r\n  }\r\n  finally {\r\n    document.body.removeChild(tempTextArea);\r\n  }\r\n\r\n  return success;\r\n}\r\n\r\nasync function copyToClipboard(text: string) {\r\n  if (!text || typeof text !== \"string\") {\r\n    console.warn(\"copyToClipboard: Invalid text provided\");\r\n    return false;\r\n  }\r\n\r\n  if (navigator?.clipboard.writeText) {\r\n    try {\r\n      await navigator.clipboard.writeText(text);\r\n      return true;\r\n    }\r\n    catch (error) {\r\n      console.warn(\"Clipboard API failed, falling back to execCommand:\", error);\r\n    }\r\n  }\r\n\r\n  return oldSchoolCopy(text);\r\n}\r\n\r\nfunction isEmpty(value: unknown): boolean {\r\n  if (value === null || value === undefined)\r\n    return true;\r\n\r\n  if (typeof value === \"string\" || Array.isArray(value))\r\n    return value.length === 0;\r\n\r\n  if (typeof value === \"object\")\r\n    return Object.keys(value).length === 0;\r\n\r\n  return false;\r\n}\r\n\r\nfunction dd(...args: unknown[]) {\r\n  for (const arg of args) {\r\n    console.dir(arg, { depth: null, colors: true });\r\n  }\r\n}\r\n\r\nasync function sleep(time: number) {\r\n  return await new Promise((resolve) => {\r\n    setTimeout(resolve, time);\r\n  });\r\n}\r\n\r\nfunction debounce(callback: CallableFunction, delay: number = 200) {\r\n  return () => {\r\n    window.setTimeout(() => {\r\n      callback();\r\n    }, delay);\r\n  };\r\n}\r\n\r\nfunction throttle(callback: () => void, time: number = 200) {\r\n  let lastTime = 0;\r\n  return () => {\r\n    const now = Date.now();\r\n    if (now - lastTime >= time) {\r\n      callback();\r\n      lastTime = now;\r\n    }\r\n  };\r\n}\r\n\r\nfunction once<T extends (...args: any[]) => any>(callback: T): T {\r\n  let result: ReturnType<T>;\r\n  let hasBeenCalled = false;\r\n\r\n  return function (this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    if (!hasBeenCalled) {\r\n      result = callback.apply(this, args);\r\n      hasBeenCalled = true;\r\n    }\r\n    return result;\r\n  } as T;\r\n}\r\n\r\nasync function promise<TReturn, TError = never>(\r\n  callback: () => TReturn | Promise<TReturn>,\r\n  errorCallback?: (error: unknown) => TError | Promise<TError>,\r\n): Promise<TReturn | TError> {\r\n  try {\r\n    return await callback();\r\n  }\r\n  catch (error: unknown) {\r\n    if (errorCallback) {\r\n      return await errorCallback(error);\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nfunction throwError(error: unknown): never {\r\n  console.error(\"Error occurred:\", error);\r\n\r\n  if (error instanceof Error) {\r\n    throw error;\r\n  }\r\n\r\n  const message\r\n    = typeof error === \"string\"\r\n      ? error\r\n      : error && typeof error === \"object\" && \"message\" in error\r\n        ? String((error as any).message)\r\n        : String(error);\r\n\r\n  throw new Error(message);\r\n}\r\n\r\nfunction after<T extends (...args: any[]) => any>(n: number, func: T): T {\r\n  let callCount = 0;\r\n  let result: ReturnType<T>;\r\n\r\n  return function (this: any, ...args: Parameters<T>): ReturnType<T> | undefined {\r\n    callCount++;\r\n    if (callCount >= n) {\r\n      result = func.apply(this, args);\r\n    }\r\n    return result;\r\n  } as T;\r\n}\r\n\r\nfunction before<T extends (...args: any[]) => any>(n: number, func: T): T {\r\n  let callCount = 0;\r\n  let result: ReturnType<T>;\r\n\r\n  return function (this: any, ...args: Parameters<T>): ReturnType<T> | undefined {\r\n    if (callCount < n) {\r\n      result = func.apply(this, args);\r\n    }\r\n    callCount++;\r\n    return result;\r\n  } as T;\r\n}\r\n\r\nexport { after, before, copyToClipboard, dd, debounce, isEmpty, once, promise, sleep, throttle, throwError };\r\n",
      "type": "registry:lib",
      "target": "lib/support/utils.ts"
    }
  ],
  "type": "registry:lib"
}